
1) Подивіться на два наступні фрагменти коду. Які переваги (Якщо вони є) у другої форми перед першою?
    // Перша версія
    while (cin.get(ch))
    {
        if (ch == " ") 
            spaces++;
        if (ch == "\n")
            newline++;
    }

    // Друга версія
    while (cin.get(ch))
    {
        if (ch == " ") 
            spaces++;
        else if (ch == "\n")
            newline++;
    }

    // В першій версії якщо ch == " " це означає що ch не може вже дорівнювати чомусь іншому, а одже друга перевірка
    // є непотрібною. В другому ж випадку цієї лишньої перевірки немає. Тому дуга версія краща за першу. 

2) Який ефект в лістінгу 6.2 дасть заміна ++ch на ch + l 
    ch це змінна типу char і ++ch збільшує код цієї змінної на один не приводячи до типу int
    а от ch+1 вже приводить результат до типу int і вивід cout покаже числовий код а не символ

3) Уважно вивчіть наступний код. Яким буде вивід??
    #include <iostream>

    using namespace std;

    int main ( )
    {
        char ch;
        int ctl, ct2;
        ctl = ct2 = 0;
        while ((ch = cin.get()) != '$')
        {
            cout << ch;
            ctl++;
            if (ch = '$')
                ct2++;
            cout << ch;
        }
        
        cout << "ctl = " << ctl << ", ct2 = " << ct2 << endl;
           
        return 0;
    }    

    // Тут допущена помилка ch = '$' тому після вводу в нас буде виводитись символ з буферу та долар. ctl1 буде рівний ctl2
    // Ну і так програма завершиться як тільки ми введемо долар. 

4) Побудуйте логічні вирази для наступний умов

    а) weight більше або рівне 115 но менше 125               // weight >= 115 && weight < 125   
    б) ch рівне q або Q                                       // ch == 'q' || ch == 'Q' 
    в) х - парне, але не рівне 26                             // x%2 == 0 && x != 26  
    г) х - парне, але не кратне 26                            // x%2 == 0 && x%26 != 0
    д) donation є в діапазоні 1000-2000 або guest дорівнює 1  // (donation > 1000 && donation < 2000) || guest == 1  
    е) ch - буква в нижньому або верхньому регістрі           // (ch >='a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') 

5) Чи являється вираз !!x тим самим що й сам x? 
    Ні не являється оскільки !x повертає true або false. Якщо x = 5 то !x поверне false так як 5 це true
    тоді !!x поверне ture тобто 1

6) Напишіть умовний вираз який еквівалентний абсолютному значенню вираза.
    if (x < 0) 
        cout << -x;
    else 
        cout << x;

7) Перепишіть наступний фрагмент використовуючи switch
    if (ch == 'А')
        a_grade++;
    else if (ch == 'В')
        b_grade++;
    else if (ch == 'С')
        c_grade++;
    else if (ch == 'D')
        d_grade++;
    else
        f_grade++ 

    switch (ch)
    {
        case 'A':
            a_grade++; break;
        case 'B':
            b_grade++; break;
        case 'C':
            c_grade++; break;
        case 'D':
            d_grade++; break;
        default:
			f_grade++; break;
    }

8) Чому в лістінгу 6.10 краще використовувати символи а і с замість цифр для вибора в меню оператора switch.
    Конкретно в цьому лістигу програма вважає що користувач введеть число а не символ. А отдже якщо ввести
    символ то програма зависне. У випадку ж з зміненним вводом через символи то цифра буде теж вважатись символом
    з своїм кодом і програма не зависне, а лишень попросить знову ввести символ

9) Перепишіть наступний фрагмент так щоб не довелось використовувати break та continue
	int line = 0;
	char ch;

	while (cin.get(ch))
	{
		if (ch == 'Q')
			break;
		if (ch != '\n')
			continue;
		line++;
	}

    // ось переписана версія

    int line = 0;
	char ch;

	while ((ch = cin.get()) != 'Q')
		if (ch == '\n')
			line++;
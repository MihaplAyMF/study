
1) Що неправильно в наступних спробах створення дружніх конструкцій?

    a)  class snap 
        {
            friend clasp; // friend class clasp;
            ...
        };
        
    б)  // class muff; 
        class cuff { 
        public: 
            void snip (muff& ) { ... } // що таке muff??
            ... 
        };
        
    в)  
        class muff 
        {
            friend void cuff::snip(muff& ); // щоб muff бачило коретко потрібно 
            ...                             // перед об'явленням cuff
        };
        class cuff                          // яке має бути перед class muff
        {                                   // написати class muff;
        public:
            void snip(muff&) { ... }
            ...
        }

2) Чи можна створити обмежену форму дружності, при якій тільки деякі
    члени класу B являтимуться дружніми для класу A і деякі члени A 
    дружніми до B.
    Ми можемо створити форму дружності так щоб лише деякі члени класу B
    являлись дружніми для класу A або навпаки, але не одночасно і це і інше
    Якщо ми спочатку об'являємо A а там є який член що має бути до нього дружнім
    з B то ми повинні попереджувально об'явити B перед A. Але у випадку якщо B
    ще матитме щось що має мати член з A то ми мали б об'явити його до B. Але ж 
    і B має бути об'явлене до A а це неможливо. Ми неможемо обв'явити два класи одночасно.

3) Які проблеми можуть виникнути в наступному об'явленні вкладеного класу?
    class Ribs
    {
    private:
        class Sauce
        {
            int soy;
            int sugar;
        public:
            Sauce(int s1, int s2) : soy(s1), sugar(s2); { }
        };
        ...
    };

    При такому об'явлені ми зможемо взаємодіяти з Sauce лише через відкриті
    інтерфейси класу Ribs. Ми можемо викликати констуктор класу Sauce лише через вікдритий
    інтерфейс, але навіть створивши об'єкт класу ми не зможемо ніяк взаємодіяти з 
    закрити об'єктами. Ні змінити, ні отримати дані, лише об'явити їх. Не зрозуміло для чого.

4) В чому різниця між throw та return
    throw використовується для того щоб генерувати виключення
    яке має бути оброблене в блоці try catch і ніде інше. Якщо
    ж цього блоку немає то буде помилка компіляції. Важлив розуміти що
    функції розкручуються до поки не вертаються в блок main. 
    а retrun він повертає значення з функції(або методу) до місця виклику
    самої функції (або методу)

5) Припустимо є іерархія класів виключень, порожених від базового класу. 
    В які послідовності варто розташувати блоки сatch?
    Блоки сatch варто розташовувати від дочірнього до батьківського,
    адже батьківський може приймати і дочірні елементи. Це означає
    що якщо першим буде батьківський, то він оброблятиме всі елементи
    включно з дочірними. 

6) Розглянемо класи Grand, Superb і Magnificient. Нехай pg вказівник 
    типу Grand*, якому присвоїли адрес об'єкта одного з трьох класів,
    а ps вказівник типу Superb*. Яка різниця в наступних прикладах коду?
    if(ps = dynamic_cast<Superb*>(pg)) // якщо pg це об'єкт класу Superb або об'ект що
        ps->say();                     // наслідується від Superb то приведення поверне
                                       // цей об'єкт, в інших випадках приведення поверне nullptr
    if(typeid(*pg) == typeid(Superb))  // В даному випадку повернеться true лише якщо  pg
        (Superb*)pg->say();            // це об'єкт класу Superb

7) Чим відрізняються static_cast від операції dynamic_cast?
    static_cast використовують в основному в тих випадках де можна 
    неявно перетворити один тип в інший, тоді як dynamic_cast
    використовуют для перевірки чи об'єкт класу можна превести
    до об'єкту іншого класу. Якщо це зробити не можна то dynamic_cast 
    повертає nullptr

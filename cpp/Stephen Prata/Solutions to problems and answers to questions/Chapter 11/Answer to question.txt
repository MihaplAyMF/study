
1) Використайте метод перегрузки операції множення в класі Stonewt. Визначте
	операцію множення полів класу на тип даних double. Врахуйте що подвоєння
	10 стоунів і 8 фунтів дає 21 стоун і 2 фунта.

   	Stonewt Stonewt::operator*(double other)
   	{
    	pds_left *= other;
   	 	stone *= other; // тут їстся точність через те що stone це тип int
    	stone += static_cast<int>(pds_left) / 14; // тому потрібно перевести все в lbs 
    	pds_left -= (static_cast<int>(pds_left) / 14 * 14); // а потім вже множити 
		return Stonewt(stone, pds_left); // і переводити назад, що вже зроблено в конструкторі
		//return Stonewt(other * pounds); // Так я до цього не дійшов сам, хоча був близько
	}

2) В чому різниця між дружньою функцією та методом?
	Дружня функція має доступ до внутрішній полів класу, проте не являється
	функцією класу. Ми не можемо викликти цю функці через об'єкти класу.
	Методи являються функцією класу і саме тому ми можемо її викликати
	через об'єкти калсу.

3) Чи повинна функція що це являється методом класу бути дружньою
	для того щоб отримати доступ до закритих полів класу? 

	Так!!!

4) Перепишіть перегружений метод операції множення класу Stonewt так щоб можна було 
	типу double множити на об'єкт цього класу. 

	Stonewt operator*(double other, Stonewt& st)
	{
		return Stonewt(other * st.pounds);
	}		

5) Які оператори не можуть бути перегружені? 
	sizeof . * :: :? typeid const_cast dynamic_cast reinterpret_cast static_cast

6) Які обмеження накладаються на перегрузку наступних операторів
	Вони не можуть виступати в ролі дружніх функції, лише як методи самого класу

7) Визначте функцію перетворення для класа Vector, яка буде приводити 
	об'єкт Vector к значенню типу double, яке представляє довжину вектора

	operator double() const { return mag; };
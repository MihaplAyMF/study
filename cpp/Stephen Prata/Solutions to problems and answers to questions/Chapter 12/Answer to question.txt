
1) Нехай клас String має наступні закриті поля
    
    class String
    {
    private:
        char* str;
        int len;
    }

    Що не так в наступному конструкторі за замовчуванням?
    String::String() {} // Прототип правильний, але оскільки в нас є 
    // вказівник, його треба ініціалізувати через nullptr або new

    Що не так в наступному конструкторі?
    String::String(const char* s) 
    { 
        str = s; // Так робити не можна!!! Треба використовувати new та strcpy
        len = strlen(s)
    } 

    Що не так в наступному конструкторі?
    String::String(const char* s)
    {
        strcpy(str, s); // Ми не виділили пам'ять для str і використовуємо її
        len = strlen(s);
    }

2)  Які три проблеми можуть виникнути при визначені класу в якому вказівник 
    ініціалізується за допомогою new
    
    1. Деструктор. Ми повинні вивільняти пам'ять

    2. Констуктор копії. Передаючи дані в функцію створюється новий об'єкт на основі 
    не створеного констркутора копії, який за замовуванням нові змінні ініціалізується
    старими змінними. При виході з функції викликається дестуктор який вивільняє пам'ять.
    Оскільки вказіник був скопійований і вивільнений, то при видаленні старих змінних
    буде помилка, адже ми пробуємо вивільнити не існуючі дані. Так тут потрібно 
    перевизначити констуктор копії, щоб він правильно копіював дані
    
    3. Оператор присвоєння. Те ж саме що і в 2 тільки при спробі присвоєти одному
    об'єкту дані з іншого об'єкта.

3) Які методи класу компілятор генерує автоматично, якщо їх не вказувати явно.

    - Конструктор
    - Деструктор
    - Конструктор копії
    - Конструктор переносу
    - Оператор присвоєння
    - Операція взяття адреса

4) Найдіть та виправьте помилки в наступному класі

    class Nifty // Назви класів пишуться з велкої букви
    {
    private:
        char* personality; // Масив не визначений, краще вказівник
        int talents;
    public: // Без цього методи будуть приватними
        Nifty();
        Nifty(const char* s); // потрібно добавити const
        friend ostream& operator<<(ostream& os, const Nifty& other); // Має бути дружньою
    }

    Nifty::Nifty() // потрібно два :: а не одне
    {
        personality = nullptr;
        talents = 0;
    }
    
    Nifty::Nifty(const char* s) 
    {
        personality = new char [strlen(s)];
        strcpy(personality, s);
        talents = 0;
    }

    ostream& Nifty::operator<<(ostream& os, const Nifty& other)
    {
        os << n.personality << '\n';
        os << n.talents << '\n';
        return os;
    }

5) В нас є наступне визначення класу

    class Golfer
    {
    private:
        char* fullname;
        int games;
        int* scores;
    public:
        Golfer();
        Golfer(const char* name, int g = 0);
        Golfer(const Golfer& other);
        ~Golfer();
    };
    
    А. Які методи викликатимуться наступними операторами?
        Golfer nancy;                       // Конуктруктор за замовчуванням    
        Golfer luly("Little Lulu");         // Консттруктор з параметрами
        Golfer roy("Roy Hobbs, 12);         // Конкструктор з параметрами
        Golfer *par = new Golfer;           // Констуктор за замовчуванням
        Golfer next = lulu;                 // Конструктор копії          
        Golfer hazzard = "Weed thwarcker";  // Констуктор з параметрами
        *par = nancy;                       // Оператор присвоєння за замовчуванням
        nancy = "Nancy Putter";             // Констуктор за замовчуванням, потім
                                            // оператор присвоєння за замовчуванням 

1) Що дочірній клас наслідує від батьківського?
    ми можемо використовувати різні модифікатори доступу які по різному впливають на наслідування
    public - модифікатор доступу який робить члени класу відкритими як для зовнішнього світу так і для класу 
    який наслідується
    private - цей модифікатор доступу робить члени класу закрити як для світу так і для наслідуваного класу
    protected - найкращий модифікатор доступу у випадку якщо нам потрібно щоб наслідуваний клас мав доступу
    до членів класу та сам клас все ще залишався закритим від зовнішнього світу.
    В основному коли ми використовуємо public або protected наслідуються методи та члени класу. 

2) Що дочірній клас не наслідує від батьківського
    В попередньому питання я пояснив за модифікатори доступу, та це не все що впливає на наслідування
    також є конструктори, деструктори, операція присвоєння та дружні функції які ніколи не наслідуються

3) Припустимо що повертаємий тим для перевизначеного методу operator=() визначений як void,
    а не ClassName&. Як це повпливає на програму? А що станеться якщо повертаємим типом буде ClassName, а не ClassName&?
    Якщо повертається void то ми все ще можемо використовувати копіювання. Просто це копіювання не повертатиме посилання
    ClassName x(); ClassName x1, x2, x3; 
    x1 = x; // Так робити можна x1.operator=(x)
    X2 = x3 = x1 // Так робити не можна x2.operator=(x3.operator=(x1)) 
    // оскільки x3.operator=(x1) повертає void виходить таке x2.operator=(void)  
    // Таке навіть виглядає дивно. Ми хочемо зкопіювати ніщо? Це як?
    Якщо ми будемо повертати не по посиланню то буде викликатись конструктор копії
    
    З звичайними функціями куди ми передаємо об'єкти класу це працює так само. Якщо передаємо по посиланню то все працює добре.
    Якщо ж ми передаємо по об'єкту то функця створює копію яку потім використовує. Якщо ж в нас динамічне виділення пам'яті
    а такого конструктора немає то виникає помилка бо після того як функція виконується викликається деструктор для нашого об'єкта
    який копіювався стандартним конструктором почленно. Тобто посилання передались вивільнились і все. Ми вже не в функції працюємо з об'єктом якогонемає
    саме тому потрібно перевизначати конструктор копіювання у випадках якщо ми працюємо з динамічним виділення пам'яті в створених класах

4) В якому порядку викилкаються конструктор і деструктори при створенні і видалення об'єкта дочірнього класу.
    Це простіше один раз показати ніж багато разів пояснювати. Тому для цього я створив два класи A та B
    Клас B наслідується від класу A. 
    
    class A
    {
    public:
        A() { cout << "Constructor A" << endl; } // А це для наглядності, щоб зрозуміти
        ~A() { cout << "Destructor A" << endl; } // в якій послідовності
    };

    class B : public A
    {
    public:
        B() { cout << "Constructor B" << endl; }  // викликаються конструктори
        ~B() { cout << "Destructor B" << endl; }  // та деструктори
    };

    void main()
    {
        {B b; }  // Constructor A // Constructor B // Destructor B // Destructor A /*Консольний вивід*/
    } // А ось і відповідь на питання, яка є ОЧЕВИДНОЮ!!

5) Якщо дочірній клас не добавляє ніяких членів даних, то чи потрібно створювати конструктор для дочірнього класу?
    Так звісно, як я писав швидше конструктор не наслідуються, а отже ми маємо створити власний конструктор.
    Якщо ж ми цього не зробити то ми не зможемо ініціалізовувати об'єкт. У випадку якщо немає ніяких данів 
    ми можемо залишити його пустим або вказати компілятору створити його звичайним за допомогою default
    B() = default; // клас з 4 відповіді

6) Припустим що і в батьківському класі і в дочірньому класі визначений метод з одни і тим же іменем. 
    Дочірній клас викликає цей метод. Який з методів буде викликаний?
    В любому випадку буде викликаний метод дочірнього класу, проте в наслідуванні прийнято методи які будуть перевизначити 
    вказувати віртуальними. Метод батьківського класу буде викликаний лише у випадку якщо дочірній клас не перевизначає цей метод.

7) В яких випадках дочірній клас повинен визначати операцію присвоювання?
    Дочірній клас повинен визначати операцію присвоювання, лише якщо в констукторах цього класу було використано операцію
    new або new []. Дочірній клас повинен визначати операцію присвоювання якщо операція присвоєння батьківського класу не 
    підходить для дочірнього класу. 

8) Чи можна присвоїти адрес об'єкта дочірнього класу вказівнику на базовий клас? І навпаки??
        
    A a, *pa;
    B b, *pb;
    
    pa = &a; // Можна
    pa = &b; // Можна, оскільки дочірній об'єкт має все те саме що й базовий
    pb = &a; // Не можна бо дочірній об'єкт може бути змінений відповідно до базового
    pb = static_cast<B*>(&a); // Можна бо ми явно приводимо &a що має тип A* в тип B* але так робити не варто
    pb = &b; // Можна

9)  Чи можна присвоїти об'єкт дочірнього класу об'єкту базового класу? І навпаки??
    
    A a, b;
    B c;
    
    a = c; // Так ми можемо робити, проте ми втрачаємо все що мав об'єкт калсу B залишається тільки наслідувана від класу A частина
    c = b; // Ми можемо так зробити якщо перевизначемо оператор присвоєння або створемо констуктор що приймає об'єкт батьківського калсу

10) Припустимо що визначена функція яка приймає в якості аргумента силку на об'єкт батьківського класу. Чому ця функція
    може також використовуватись в якості аргумента об'єкта дочірнього класу?
    Це допустимо тому що с++ позволяє силці базового класу вказувати на об'єкти дочірнього класу

11) Припустимо що визначена функція яка приймає в якості аргумента об'єкт батьківського класу. Чому ця функція
    може також використовуватись в якості аргумента об'єкта дочірнього класу?
    Оскільки ми передаємо об'єкт не по силці а по значенню то при передачі викликається коструктор копіювання, а оскільки
    ми хочемо отримати об'єкт базового класу то і викилкається констуктор окпіювання базового класу який копіює лише ту частину
    дочірнього класу який той наслідує від батьківського класу. Саме тому в функції ми отримаємо об'єкт базового класу.

12) Чому зазвичай краще передавати об'єкти по силці, а не по значенню? 
    Тому що передача по значенню викликає консуктор копіювання що зповільнює програму, а в більшості
    випадків робити копію об'єкта не доречно.

13) Допустимо що Corporation - батьківський клас, а PublicCorporation - дочірній.
    Також допустимо що в кожному з них визначений метод head(). ph являєтся вказівником на тип 
    Corporation, проте цій змінній присвоїли адрес об'єкта PublicCorporation. Як с++ інтрапретує 
    ph->head(), якщо в базовому класі визначений head() як:
    a) звичайний метод
    Якщо метод вказаний як звичайний то ph->head() викличе метод батьківського класу
    б) віртуальний метод
    Якщо метод вказаний як віртуальний то ph->head() викличе метод дочірнього класу

14) Чи є помилка в наступному коді?? 

    class Kitchen 
    {
    private:
        double kit_sq_ft
    public:
        Kitchen(){ kit_sq_ft = 0.0}
        virtual double area() const { return kit_sq_ft * kit_sq_ft; }
    };

    class House : public Kitchen // А ось і перша помилка, тут ми порушуємо правило "являється" 
    // Будинок не являється частиною кухня, а от кухня може бути частиною будинку
    {
    private:
        double all_sq_ft
    public:
        House(){ all_sq_ft += kit_sq_ft} // Ми пробуємо до неініціалізованої змінної додавати щось???
        virtual double area(const char *s) const { cout << s; return all_sq_ft; } // area має іншу сигнатуру, так не можна при наслідуванні 
    };
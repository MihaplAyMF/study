
1) Назвіть три кроки створення функції
    Об'являємо прототип функції
    Ініціалізуємо тіло функції
    Викликаємо функцію 

2) Побудуйте прототипи що будуть відповідати наступним описам
    a) igor() // не приймає і не повертає нічого
        void igor(); 
    b) tofu() // приймає аргумент int і повертає float
        float tofu(int); 
    c) mpg() // приймає два аргументи double і повертає double
        double mpg(double, double);
    d) summation() // приймає ім'я масива типу long його розмір і повертає тип long
        long summation(lond arr[], int size)
    e) doctor() // приймає строковий аргумент і повертає double
        double doctor(const char name[]);
    f) ofcourse() // приймає структуру boss і не повертає нічого
        void doctor(boss);
    g) plot() // приймає структуру map і повертає строку
        string plot(Map* m);

3) Напишіть функцію що приймає три аргументи: ім'я масиву int, його розмір і значення int. 
    Функція повинна присвоєте значення в усі елементи масиву

    void ChangeArr(int arr[], int size, int n)
    {
        for (int i = 0; i < size; i++)
            arr[i] = n;
    }

4) Напишіть функцію що приймає три аргументи: вказівник на перший елементи діапазона в масиві, вказівник на елемент що слідує 
    за кінцем діапазона і значення int. Функція повинна присвоювати кожному елементу діапазона масива значення int

    void ChangeArr(int* arr1, int* arr2, int n)
    {
        for (int i = 0; i < arr2-arr1; i++)
            arr1[i] = n;
    }

5)  Напишіть функцію що приймає ім'я масива double і його розмір в якості аргументів і повертає найбільше значення яке є в цьому масиві. 
     Функція не повинна міняти вміст масиву 

    double MaxValue(double arr[], int size)
    {
        int max = arr[0];
        for(int i = 1; i < size; i++)
        {
            if(max < arr[i])
                max = arr[i];
        }
    }

6) Чому ви не використовуєте кваліфікатор const для аргументів функції, що відносяться до базових типів?
    Тому що функія створює свої локальні дані. А отже ми навіть якщо дуже захочемо
    не зможемо змінити значення тих базових даних які передаємо у функцію

7) Які три форми строк в стилі с можна зустріти в програмах на с++?
    char name1[] = "Test";      // Масив символів
    const char* name2 = "dfgr"; // Строкова константа
    const char* name3 = name2;  // Силка на перший елемент строковий

8) Напишіть функцію, що має наступний протопи:
    int replace(char* str, char c1, char с2);
    Ця функцыя повинна замыняти кожне появлення c1 на c2 в строці str і повертати кількість виконаних операцій 
    
    int replace(char* str, char c1, char c2)
    {
        int n {};

        while (*str)
        {
            if (*str == c1)
            {
                *str = c2;
                n++;
            }
            str++;
        }

        return n;
    } 

9) Що означає вираз *"pizza"? А як що до "taco"[2]? 
    *"pizza" повертає значення першого адреса тобто p
    "taco"[2] верне третій елемент масиву тобто'c'

10) С++ позволяє передати структуру по значенню або ж адрес структури.
     Якщо glitz - структурна змінна, як передати її по значення?
     Як передати її по адресу? Який підхід кращий? Чому?

     Обидва підходи хороші по своєму. Якщо ми хочемо передати glits по значенню
     то ми просто передаємо його ім'я, якщо ж по адресу то потрібно викоирстовувати
     & для отриманна адреса &glitz

     У випадку якщо нам потрібно економити пам'ять краще передавати по адресу, якщо передати 
     не по адресу то у функції створюється копія glitz а це вимагає виділення пам'яті на час
     поки функція не завершить своє виконання. У випадку ж передачі по адресу ми працюємо
     на пряму з пам'ятю де записана ця структура. 

11) Функція judge() повертає тип int. В якості аргументів вона приймає
     адрес функції. Функція, адрес якої передається в свою чергу приймає аргумент типу const char і повертає int
     напишіть прототип цієї функції

     int f1(const char);
     int judge(int (*f)(const char)); 

12) Припустимо що э наступне об'явлення структури:
    struct applicant {
        char name[30];
        int credit_ratings[3];
    };
    a) Напишіть фукнцію, яка приймає структуру applicant в якосты аргумента і виводить її змість
        void PrintApplicant(applicant app)
        {
            cout << app.name << endl;
            for (int i = 0; i < 3; i++)
                cout << app.credit_ratings[i] << endl;
        }
    b) Напишіть фукнцію, яка приймає адрес структури applicant в якосты аргумента і виводить змість стуктури, на яку він вказує
        void PrintApplicantLink(applicant* app)
        {
            cout << app->name << endl;
            for (int i = 0; i < 3; i++)
                cout << app->credit_ratings[i] << endl;
        }

13) Припустимо, що функція f1() і f2() мають наступні прототипи:
    void f1(applicant* а);
    const char* f2(const applicant* a1, const applicant* а2) ;
    
    
    Об'явіть p1 як вказівник на функцію f1, а p2 - як вказівник на f2. 
    	void (*p1)(applicant*) = f1;
	    const char* (*p2)(const applicant*, const applicant*) = f2;
    
    використовуйте typedef
        typedef void (*p_fl1) (applicant*);
        typedef const char* (*p_fl2)(const applicant*, const applicant*);
        
        p_fl1 p1 = f1;
        p_fl2 p2 = f2;
    
    Об'явіть вказівника на масив з 10 вказівників того ж типа що й p2 
        p_fl2 (*pa)[10];